package lesson4

// 4.1
// bfs の探索で探索したいデータを受け取って、一致するものがあればboolを返すように改修する。

// 4.2
// 配列の真ん中だけ取得して、あとは普通に二分木を作ればいい。

// 4.3
// 深さ優先、または幅優先の探索を使って実装できる。
// 木構造の場合、深さ優先はpre-orderの探索である。
// 以下のようなインターフェースにして、再帰するときに level を繰り上げる。
// func search(root *Node, listInLists [][]*Node, level int)

// 4.4
// 各Nodeの高さを再起的に調べて、高さの差が1より大きいければ、falseを返却するようなメソッドを用意する。

// 4.5
// 1. in-orderで探索して、探索した箇所をリストにコピーして、ソートされているかどうかを確認する方法
//	最後に訪れた場所の値で比較すればいいだけなので、リストではなくてグローバル変数に持っておくでもいい。
// 2. 左の枝は親ノードより大きい値はない、右の枝は親ノードより小さい値はないので、その条件で再起的な関数を実装する。

// 4.6
// 有効グラフを作成する
// 有効グラフは、まず全てのノードをリストで保持している。
// 各ノードは、全ての子ノードをリストで持っている。また、map[ノード名]ノード、のハッシュマップを保持している。
// other: 他の方法として、トポロジカルソートを使用する方法もある。

// 木構造や、グラフ、探索の実装方法が分かったので、あとは一旦飛ばす。
